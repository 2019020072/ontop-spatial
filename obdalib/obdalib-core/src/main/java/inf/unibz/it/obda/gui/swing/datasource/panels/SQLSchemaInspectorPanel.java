/***
 * Copyright (c) 2008, Mariano Rodriguez-Muro. All rights reserved.
 * 
 * The OBDA-API is licensed under the terms of the Lesser General Public License
 * v.3 (see OBDAAPI_LICENSE.txt for details). The components of this work
 * include:
 * 
 * a) The OBDA-API developed by the author and licensed under the LGPL; and, b)
 * third-party components licensed under terms that may be different from those
 * of the LGPL. Information about such licenses can be found in the file named
 * OBDAAPI_3DPARTY-LICENSES.txt.
 */

package inf.unibz.it.obda.gui.swing.datasource.panels;

import inf.unibz.it.obda.api.controller.DatasourcesController;
import inf.unibz.it.obda.domain.DataSource;
import inf.unibz.it.obda.gui.swing.datasource.DatasourceSelectorListener;
import inf.unibz.it.obda.gui.swing.utils.OBDAProgessMonitor;
import inf.unibz.it.obda.gui.swing.utils.OBDAProgressListener;
import inf.unibz.it.obda.model.impl.RDBMSsourceParameterConstants;
import inf.unibz.it.sql.JDBCConnectionManager;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.concurrent.CountDownLatch;

import javax.swing.BorderFactory;
import javax.swing.DefaultListSelectionModel;
import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.ScrollPaneConstants;
import javax.swing.UIManager;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableModel;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 
 * @author mariano
 */
public class SQLSchemaInspectorPanel extends javax.swing.JPanel implements DatasourceSelectorListener {

	/**
	 * 
	 */
	private static final long		serialVersionUID	= 6497114195036386873L;

	private static final int		TABLE_ROW_HEIGHT	= 17;

	private static final int		TABLE_COLUMN_WITH	= 200;

	private DataSource				selectedSource;

	private DatasourcesController	dscontroller		= null;

	Logger							log					= LoggerFactory.getLogger(SQLSchemaInspectorPanel.class);

	/** Creates new form SQLSchemaInspectorPanel */
	public SQLSchemaInspectorPanel(DatasourcesController dsController) {
		this.dscontroller = dsController;

		initComponents();
		addPopupMenu();
		/***********************************************************************
		 * Setting up the database utilities
		 */

		tblRelations.getSelectionModel().setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);
		tblRelations.getSelectionModel().addListSelectionListener(new RowListener());
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		pnlButtons = new JPanel();
		cmdRefresh = new JButton();
		splRelationsColumns = new JSplitPane();
		scrRelationsTable = new JScrollPane();
		tblRelations = new JTable();
		scrAttributesTable = new JScrollPane();
		tblAttributes = new JTable();

		setLayout(new BorderLayout());

		pnlButtons.setAutoscrolls(true);
		pnlButtons.setMinimumSize(new Dimension(100, 0));
		pnlButtons.setPreferredSize(new Dimension(100, 35));
		pnlButtons.setLayout(new FlowLayout(FlowLayout.RIGHT));

		cmdRefresh.setText("Refresh");
		cmdRefresh.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				cmdRefreshActionPerformed(evt);
			}
		});
		pnlButtons.add(cmdRefresh);

		add(pnlButtons, BorderLayout.NORTH);

		splRelationsColumns.setOrientation(JSplitPane.VERTICAL_SPLIT);
		splRelationsColumns.setResizeWeight(0.5);
		splRelationsColumns.setMinimumSize(new Dimension(100, 100));
		splRelationsColumns.setPreferredSize(new Dimension(100, 100));

		scrRelationsTable.setBorder(BorderFactory.createTitledBorder("Relations"));
		scrRelationsTable.setMinimumSize(new Dimension(250, 100));
		scrRelationsTable.setOpaque(false);
		scrRelationsTable.setPreferredSize(new Dimension(250, 100));

		tblRelations.setModel(new DefaultTableModel(new Object[][] {

		}, new String[] { "Relation Name", "Row Count" }) {
			Class[]		types	= new Class[] { String.class, String.class };
			boolean[]	canEdit	= new boolean[] { false, false };

			public Class getColumnClass(int columnIndex) {
				return types[columnIndex];
			}

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});
		tblRelations.setPreferredSize(new Dimension(150, 999999));
		scrRelationsTable.setViewportView(tblRelations);

		splRelationsColumns.setTopComponent(scrRelationsTable);

		scrAttributesTable.setBackground(UIManager.getDefaults().getColor("InternalFrame.borderColor"));
		scrAttributesTable.setBorder(BorderFactory.createTitledBorder("Columns"));
		scrAttributesTable.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		scrAttributesTable.setMinimumSize(new Dimension(250, 100));
		scrAttributesTable.setPreferredSize(new Dimension(250, 100));

		tblAttributes.setModel(new DefaultTableModel(new Object[][] {

		}, new String[] { "Field", "Type", "Null", "Key", "Default", "Extra" }) {
			boolean[]	canEdit	= new boolean[] { false, false, false, false, false, false };

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});
		tblAttributes.setPreferredSize(new Dimension(150, 2000));
		scrAttributesTable.setViewportView(tblAttributes);

		splRelationsColumns.setBottomComponent(scrAttributesTable);

		add(splRelationsColumns, BorderLayout.CENTER);
	}// </editor-fold>//GEN-END:initComponents

	private void addPopupMenu() {
		JPopupMenu menu = new JPopupMenu();

		JMenuItem countAll = new JMenuItem();
		countAll.setText("count all");
		countAll.setToolTipText("Counts the number of rows in each table");
		countAll.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {

				try {
					int row = tblRelations.getSelectedRow();
					if (row != -1) {
						String s = tblRelations.getModel().getValueAt(row, 0).toString();
						CountDownLatch latch = new CountDownLatch(1);
						OBDAProgessMonitor monitor = new OBDAProgessMonitor();
						CountAllTuplesAction action = new CountAllTuplesAction(latch);
						monitor.addProgressListener(action);
						monitor.start();
						action.run();
						latch.await();
						monitor.stop();
						String[] result = action.getResult();
						if (result != null) {
							for (int i = 0; i < result.length; i++) {
								tblRelations.getModel().setValueAt(result[i], i, 1);
							}
						}

					}

				} catch (InterruptedException e1) {
					JOptionPane.showMessageDialog(null, "Error while counting.\n Please refer to the log file for more information.");
					log.error("Error while counting.", e);
				}
			}

		});
		menu.add(countAll);
		JMenuItem countrow = new JMenuItem();
		countrow.setText("count");
		countrow.setToolTipText("Counts the number of rows in the selected table");
		countrow.addActionListener(new ActionListener() {

			// @Override
			public void actionPerformed(ActionEvent e) {
				try {
					int row = tblRelations.getSelectedRow();
					if (row != -1) {
						String s = tblRelations.getModel().getValueAt(row, 0).toString();
						CountDownLatch latch = new CountDownLatch(1);
						OBDAProgessMonitor monitor = new OBDAProgessMonitor();
						CountTuplesAction action = new CountTuplesAction(latch, s);
						monitor.addProgressListener(action);
						monitor.start();
						action.run();
						latch.await();
						monitor.stop();
						String count = action.getResult();
						if (!count.equals("-1")) {
							tblRelations.getModel().setValueAt(count, row, 1);
						}

					}

				} catch (InterruptedException e1) {
					JOptionPane.showMessageDialog(null, "Error while counting.\n Please refer to the log file for more information.");
					log.error("Error while counting.", e);
				}
			}
		});
		menu.add(countrow);
		tblRelations.setComponentPopupMenu(menu);
	}

	private void cmdRefreshActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_cmdRefreshActionPerformed
		try {
			OBDAProgessMonitor progMonitor = new OBDAProgessMonitor();
			CountDownLatch latch = new CountDownLatch(1);
			UpdateRelationTableAction action = new UpdateRelationTableAction(latch);
			progMonitor.addProgressListener(action);
			progMonitor.start();
			action.run();
			latch.await();
			progMonitor.stop();
			ResultSet set = action.getResult();
			if (set != null) {
				RelationsResultSetTableModel model = new RelationsResultSetTableModel(set, selectedSource);
				tblRelations.setModel(model);
				tblRelations.setPreferredSize(new Dimension(model.getColumnCount() * TABLE_COLUMN_WITH, model.getRowCount()
						* TABLE_ROW_HEIGHT));
			}
		} catch (Exception e) {
			JOptionPane.showMessageDialog(this, "Error while updating table.\n Please refer to the log file for more information.");
			log.error("Error while updating table model.", e);
		}
	}// GEN-LAST:event_cmdRefreshActionPerformed

	@Override
	public void datasourceChanged(DataSource oldSource, DataSource newSource) {
		this.selectedSource = newSource;
	}

	/***************************************************************************
	 * Called when the relation table of the RDBMS inspector changed
	 */
	private class RowListener implements ListSelectionListener {
		public void valueChanged(ListSelectionEvent event) {
			if (event.getValueIsAdjusting()) {
				return;
			}
			int row = tblRelations.getSelectedRow();

			// final DataSource current_datasource =
			// DatasourcesController.getInstance().getCurrentDataSource();
			final String relation = (String) tblRelations.getValueAt(row, 0);
			if (relation.equals(""))
				return;
			EventQueue.invokeLater(new Runnable() {
				public void run() {
					try {

						JDBCConnectionManager factory = JDBCConnectionManager.getJDBCConnectionManager();

						TableModel oldmodel = tblAttributes.getModel();

						if ((oldmodel != null) && (oldmodel instanceof ResultSetTableModel)) {
							ResultSetTableModel rstm = (ResultSetTableModel) oldmodel;
							rstm.close();
						}

						// ResultSetTableModel model =
						// factory.getResultSetTableModel("describe " + relation
						// + ";");
						ColumnInspectorTableModel model = factory.getTableDescriptionTableModel(selectedSource, relation);
						tblAttributes.setModel(model);
						tblAttributes.setPreferredSize(new Dimension(model.getColumnCount() * TABLE_COLUMN_WITH, model.getRowCount()
								* TABLE_ROW_HEIGHT));
					} catch (SQLException ex) {
						ex.printStackTrace(System.err);
						System.err.println(ex.getErrorCode());
						JOptionPane.showMessageDialog(null, new String[] { ex.getClass().getName() + ": ", ex.getMessage() });
					} catch (ClassNotFoundException ex) {
						ex.printStackTrace(System.err);
						JOptionPane.showMessageDialog(null, new String[] { "JDBC Driver Missing. Make sure the JDBC jar",
								"is accesible in the classpath." });

					} catch (Exception e) {
						e.printStackTrace(System.err);
					}
				}
			});
		}
	}

	private ResultSet getResultSetForRelations() throws Exception {
		if (selectedSource == null) {
			JOptionPane.showMessageDialog(this, "Select a datasource first");
		}
		Connection con = JDBCConnectionManager.getJDBCConnectionManager().getConnection(selectedSource);
		if (con == null)
			throw new SQLException("Couldnt establish a connectino for the datsource: {}" + selectedSource.getSourceID());

		if (selectedSource.getParameter(RDBMSsourceParameterConstants.DATABASE_DRIVER).equals("com.ibm.db2.jcc.DB2Driver")) {

			Statement statement = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			String url = selectedSource.getParameter(RDBMSsourceParameterConstants.DATABASE_URL);
			// jdbc:db2://5.90.168.104:50000/MINIST:currentSchema=PROP;
			String[] sp1 = url.split("/");
			String catalog = sp1[sp1.length - 1].split(":")[0];
			String t2 = url.split("=")[1];
			String schema = t2.substring(0, t2.length() - 1);
			ResultSet r = statement.executeQuery("SELECT TABLE_NAME FROM SYSIBM.TABLES WHERE TABLE_CATALOG = '" + catalog
					+ "' AND TABLE_SCHEMA = '" + schema + "'");
			return r;
		}
		if (selectedSource.getParameter(RDBMSsourceParameterConstants.DATABASE_DRIVER).equals("oracle.jdbc.driver.OracleDriver")) {
			// select table_name from user_tables
			Statement statement = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			ResultSet r = statement.executeQuery("select table_name from user_tables");
			return r;
		} else {
			// postgres and mysql
			DatabaseMetaData metdata = con.getMetaData();
			String catalog = null;
			String schemaPattern = "%";
			String tableNamePattern = "%";
			String types[] = { "TABLE" };
			con.setAutoCommit(true);
			ResultSet r = metdata.getTables(catalog, schemaPattern, tableNamePattern, types);
			con.setAutoCommit(false);
			return r;
		}

	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private JButton		cmdRefresh;
	private JPanel		pnlButtons;
	private JScrollPane	scrAttributesTable;
	private JScrollPane	scrRelationsTable;
	private JSplitPane	splRelationsColumns;
	private JTable		tblAttributes;
	private JTable		tblRelations;

	// End of variables declaration//GEN-END:variables

	private class CountTuplesAction implements OBDAProgressListener {

		CountDownLatch	latch		= null;
		Thread			thread		= null;
		String			result		= "-1";
		String			table		= null;
		Statement		statement	= null;

		private CountTuplesAction(CountDownLatch latch, String table) {
			this.latch = latch;
			this.table = table;
		}

		public String getResult() {
			return result;
		}

		public void run() {
			thread = new Thread() {
				public void run() {
					try {
						Connection con = JDBCConnectionManager.getJDBCConnectionManager().getConnection(selectedSource);
						statement = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
						ResultSet r = statement.executeQuery("SELECT COUNT(*) FROM " + table.toUpperCase());
						r.next();
						if (r.first()) {
							Object temp = r.getObject(1);
							String count = temp.toString();
							result = count;
						}
						latch.countDown();
					} catch (Exception e) {
						latch.countDown();
						JOptionPane.showMessageDialog(null, "Error while counting tuples in " + table
								+ ".\n Please refer to the log file for more information.");
						log.error("Error while counting tuples in " + table, e);
					}
				}
			};
			thread.start();
		}

		@Override
		public void actionCanceled() {
			try {
				if (thread != null) {
					thread.interrupt();
				}
				if (statement != null && !statement.isClosed()) {
					statement.cancel();
					statement.close();
				}
				latch.countDown();
			} catch (SQLException e) {
				latch.countDown();
				JOptionPane.showMessageDialog(null, "Error while canceling action.\n Please refer to the log file for more information.");
				log.error("Error while counting tuples.", e);
			}
		}

	}

	private class CountAllTuplesAction implements OBDAProgressListener {

		CountDownLatch	latch		= null;
		Thread			thread		= null;
		String[]		result		= null;
		Statement		statement	= null;

		private CountAllTuplesAction(CountDownLatch latch) {
			this.latch = latch;
		}

		public String[] getResult() {
			return result;
		}

		public void run() {
			thread = new Thread() {
				public void run() {
					try {
						int rows = tblRelations.getRowCount();
						result = new String[rows];
						for (int i = 0; i < rows; i++) {
							String s = tblRelations.getModel().getValueAt(i, 0).toString();
							Connection con = JDBCConnectionManager.getJDBCConnectionManager().getConnection(selectedSource);
							statement = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
							ResultSet r = statement.executeQuery("SELECT COUNT(*) FROM " + s.toUpperCase());
							r.next();
							if (r.first()) {
								Object temp = r.getObject(1);
								String count = temp.toString();
								result[i] = count;
							} else {
								result[i] = "count error";
							}
							statement.close();
						}
						latch.countDown();
					} catch (Exception e) {
						latch.countDown();
						JOptionPane.showMessageDialog(null,
								"Error while counting tuples.\n Please refer to the log file for more information.");
						log.error("Error while counting tuples.", e);
					}
				}
			};
			thread.start();
		}

		@Override
		public void actionCanceled() {
			try {
				if (thread != null) {
					thread.interrupt();
				}
				if (statement != null && !statement.isClosed()) {
					statement.cancel();
					statement.close();
				}
				latch.countDown();
			} catch (SQLException e) {
				latch.countDown();
				JOptionPane.showMessageDialog(null, "Error while canceling action.\n Please refer to the log file for more information.");
				log.error("Error while counting tuples.", e);
			}
		}

	}

	private class UpdateRelationTableAction implements OBDAProgressListener {

		CountDownLatch	latch	= null;
		Thread			thread	= null;
		ResultSet		result	= null;

		private UpdateRelationTableAction(CountDownLatch latch) {
			this.latch = latch;
		}

		@Override
		public void actionCanceled() {
			if (thread != null) {
				thread.interrupt();
			}
			latch.countDown();
		}

		public ResultSet getResult() {
			return result;
		}

		public void run() {
			thread = new Thread() {
				public void run() {
					try {
						result = getResultSetForRelations();
						latch.countDown();
					} catch (Exception e) {
						latch.countDown();
						log.error("Error while retriving information from the data source.", e);
						JOptionPane.showMessageDialog(null,
								"Error while updating table.\n Please refer to the log file for more information.");
					}
				}
			};
			thread.start();
		}
	}

}
