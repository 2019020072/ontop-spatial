/***
 * Copyright (c) 2008, Mariano Rodriguez-Muro. All rights reserved.
 * 
 * The OBDA-API is licensed under the terms of the Lesser General Public License
 * v.3 (see OBDAAPI_LICENSE.txt for details). The components of this work
 * include:
 * 
 * a) The OBDA-API developed by the author and licensed under the LGPL; and, b)
 * third-party components licensed under terms that may be different from those
 * of the LGPL. Information about such licenses can be found in the file named
 * OBDAAPI_3DPARTY-LICENSES.txt.
 */

package it.unibz.krdb.obda.gui.swing.panel;

import it.unibz.krdb.obda.gui.swing.treemodel.ColumnInspectorTableModel;
import it.unibz.krdb.obda.gui.swing.treemodel.RelationsResultSetTableModel;
import it.unibz.krdb.obda.gui.swing.treemodel.ResultSetTableModel;
import it.unibz.krdb.obda.gui.swing.utils.DatasourceSelectorListener;
import it.unibz.krdb.obda.gui.swing.utils.OBDAProgessMonitor;
import it.unibz.krdb.obda.gui.swing.utils.OBDAProgressListener;
import it.unibz.krdb.obda.model.OBDADataSource;
import it.unibz.krdb.obda.model.impl.RDBMSourceParameterConstants;
import it.unibz.krdb.sql.DBMetadata;
import it.unibz.krdb.sql.JDBCConnectionManager;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.concurrent.CountDownLatch;

import javax.swing.BorderFactory;
import javax.swing.DefaultListSelectionModel;
import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableModel;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SQLSchemaInspectorPanel extends javax.swing.JPanel implements DatasourceSelectorListener {

	private static final long serialVersionUID = 6497114195036386873L;

	private static final int TABLE_ROW_HEIGHT = 17;
	private static final int TABLE_COLUMN_WIDTH = 200;

	private OBDADataSource selectedSource;

	private Logger log = LoggerFactory.getLogger(SQLSchemaInspectorPanel.class);

	/** Creates new form SQLSchemaInspectorPanel */
	public SQLSchemaInspectorPanel() {
		initComponents();
		addPopupMenu();

		tblRelations.getSelectionModel().setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);
		tblRelations.getSelectionModel().addListSelectionListener(new RowListener());
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		pnlButtons = new JPanel();
		cmdRefresh = new JButton();
		splRelationsColumns = new JSplitPane();
		scrRelationsTable = new JScrollPane();
		tblRelations = new JTable();
		scrAttributesTable = new JScrollPane();
		tblAttributes = new JTable();

		setLayout(new BorderLayout());

		pnlButtons.setAutoscrolls(true);
		pnlButtons.setMinimumSize(new Dimension(100, 0));
		pnlButtons.setPreferredSize(new Dimension(100, 35));
		pnlButtons.setLayout(new FlowLayout(FlowLayout.RIGHT));

		cmdRefresh.setText("Refresh Schema");
		cmdRefresh.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				cmdRefreshActionPerformed(evt);
			}
		});
		pnlButtons.add(cmdRefresh);

		add(pnlButtons, BorderLayout.NORTH);

		splRelationsColumns.setOrientation(JSplitPane.VERTICAL_SPLIT);
		splRelationsColumns.setResizeWeight(0.5);
		splRelationsColumns.setMinimumSize(new Dimension(100, 100));
		splRelationsColumns.setPreferredSize(new Dimension(100, 100));

		scrRelationsTable.setBorder(BorderFactory.createTitledBorder("Relations"));
		scrRelationsTable.setMinimumSize(new Dimension(250, 100));
		scrRelationsTable.setOpaque(false);
		scrRelationsTable.setPreferredSize(new Dimension(250, 100));

		tblRelations.setModel(new DefaultTableModel(new Object[][] {}, new String[] { "Relation Name", "Row Count" }) {
			Class[] types = new Class[] { String.class, String.class };
			boolean[] canEdit = new boolean[] { false, false };

			@Override
			public Class getColumnClass(int columnIndex) {
				return types[columnIndex];
			}

			@Override
			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});
		tblRelations.setPreferredSize(new Dimension(150, 999999));
		scrRelationsTable.setViewportView(tblRelations);

		splRelationsColumns.setTopComponent(scrRelationsTable);

		scrAttributesTable.setBackground(UIManager.getDefaults().getColor("InternalFrame.borderColor"));
		scrAttributesTable.setBorder(BorderFactory.createTitledBorder("Columns"));
		scrAttributesTable.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		scrAttributesTable.setMinimumSize(new Dimension(250, 100));
		scrAttributesTable.setPreferredSize(new Dimension(250, 100));

		tblAttributes.setModel(new DefaultTableModel(new Object[][] {}, new String[] { "Attribute", "Type", "Primary Key", "Nullable" }) {
			boolean[] canEdit = new boolean[] { false, false, false, false };

			@Override
			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});
		tblAttributes.setPreferredSize(new Dimension(150, 2000));
		scrAttributesTable.setViewportView(tblAttributes);

		splRelationsColumns.setBottomComponent(scrAttributesTable);

		add(splRelationsColumns, BorderLayout.CENTER);
	}// </editor-fold>//GEN-END:initComponents

	private void addPopupMenu() {
		JPopupMenu menu = new JPopupMenu();

		JMenuItem countAll = new JMenuItem();
		countAll.setText("Count All");
		countAll.setToolTipText("Counts the number of rows in each table");
		countAll.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				try {
					int row = tblRelations.getSelectedRow();
					if (row != -1) {
						CountDownLatch latch = new CountDownLatch(1);
						OBDAProgessMonitor monitor = new OBDAProgessMonitor("Counting all tuples...");
						CountAllTuplesAction action = new CountAllTuplesAction(latch);
						monitor.addProgressListener(action);
						monitor.start();
						action.run();
						latch.await();
						monitor.stop();
						String[] result = action.getResult();
						if (result != null) {
							for (int i = 0; i < result.length; i++) {
								tblRelations.getModel().setValueAt(result[i], i, 1);
							}
						}
					}
				} catch (InterruptedException e1) {
					JOptionPane.showMessageDialog(null, "Error while counting.\n Please refer to the log file for more information.");
					log.error("Error while counting.", e);
				}
			}
		});
		menu.add(countAll);

		JMenuItem countrow = new JMenuItem();
		countrow.setText("Count");
		countrow.setToolTipText("Counts the number of rows in the selected table");
		countrow.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				try {
					int row = tblRelations.getSelectedRow();
					if (row != -1) {
						String s = tblRelations.getModel().getValueAt(row, 0).toString();
						CountDownLatch latch = new CountDownLatch(1);
						OBDAProgessMonitor monitor = new OBDAProgessMonitor("Counting all tuples...");
						CountTuplesAction action = new CountTuplesAction(latch, s);
						monitor.addProgressListener(action);
						monitor.start();
						action.run();
						latch.await();
						monitor.stop();
						String count = action.getResult();
						if (!count.equals("-1")) {
							tblRelations.getModel().setValueAt(count, row, 1);
						}
					}
				} catch (InterruptedException e1) {
					JOptionPane.showMessageDialog(null, "Error while counting.\n Please refer to the log file for more information.");
					log.error("Error while counting.", e);
				}
			}
		});
		menu.add(countrow);

		tblRelations.setComponentPopupMenu(menu);
	}

	private void cmdRefreshActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_cmdRefreshActionPerformed
		Runnable run = new Runnable() {
			@Override
			public void run() {
				try {
					OBDAProgessMonitor progMonitor = new OBDAProgessMonitor("Counting all tuples...");
					progMonitor.start();
					CountDownLatch latch = new CountDownLatch(1);
					UpdateRelationTableAction action = new UpdateRelationTableAction(latch);
					progMonitor.addProgressListener(action);
					action.run();
					latch.await();
					progMonitor.stop();
					ResultSet set = action.getResult();
					if (set != null) {
						RelationsResultSetTableModel model = new RelationsResultSetTableModel(set, selectedSource);
						tblRelations.setModel(model);
						tblRelations.setPreferredSize(new Dimension(model.getColumnCount() * TABLE_COLUMN_WIDTH, model.getRowCount()
								* TABLE_ROW_HEIGHT));
					}
				} catch (Exception e) {
					JOptionPane.showMessageDialog(SQLSchemaInspectorPanel.this,
							"Error while updating table.\n Please refer to the log file for more information.");
					log.error("Error while updating table model.", e);
				}
			}
		};

		if (selectedSource == null) {
			JOptionPane.showMessageDialog(this, "Select a datasource first!", "Error", JOptionPane.ERROR_MESSAGE);
		} else {
			SwingUtilities.invokeLater(run);
		}
	}// GEN-LAST:event_cmdRefreshActionPerformed

	@Override
	public void datasourceChanged(OBDADataSource oldSource, OBDADataSource newSource) {
		this.selectedSource = newSource;
	}

	private class RowListener implements ListSelectionListener {
		public void valueChanged(ListSelectionEvent event) {
			if (event.getValueIsAdjusting()) {
				return;
			}

			final int row = tblRelations.getSelectedRow();
			final String table = (String) tblRelations.getValueAt(row, 0);
			if (table.equals("")) {
				return;
			}

			EventQueue.invokeLater(new Runnable() {
				public void run() {
					try {
						JDBCConnectionManager conn = JDBCConnectionManager.getJDBCConnectionManager();
						TableModel oldmodel = tblAttributes.getModel();
						if ((oldmodel != null) && (oldmodel instanceof ResultSetTableModel)) {
							ResultSetTableModel rstm = (ResultSetTableModel) oldmodel;
							rstm.close();
						}
						DBMetadata metadata = conn.getMetaData(selectedSource.getSourceID());
						ColumnInspectorTableModel model = new ColumnInspectorTableModel(metadata, table);

						tblAttributes.setModel(model);

						Dimension dimension = new Dimension(model.getColumnCount() * TABLE_COLUMN_WIDTH, model.getRowCount()
								* TABLE_ROW_HEIGHT);
						tblAttributes.setPreferredSize(dimension);
					} catch (Exception e) {
						e.printStackTrace(System.err);
					}
				}
			});
		}
	}

	private ResultSet getResultSetForRelations() throws Exception {

		Connection conn = JDBCConnectionManager.getJDBCConnectionManager().getConnection(selectedSource.getSourceID());

		if (selectedSource.getParameter(RDBMSourceParameterConstants.DATABASE_DRIVER).equals("com.ibm.db2.jcc.DB2Driver")) {
			Statement statement = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			String url = selectedSource.getParameter(RDBMSourceParameterConstants.DATABASE_URL);
			// jdbc:db2://5.90.168.104:50000/MINIST:currentSchema=PROP;
			String[] sp1 = url.split("/");
			String catalog = sp1[sp1.length - 1].split(":")[0];
			String t2 = url.split("=")[1];
			String schema = t2.substring(0, t2.length() - 1);
			ResultSet r = statement.executeQuery("SELECT TABLE_NAME FROM SYSIBM.TABLES WHERE TABLE_CATALOG = '" + catalog
					+ "' AND TABLE_SCHEMA = '" + schema + "'");
			return r;
		} else if (selectedSource.getParameter(RDBMSourceParameterConstants.DATABASE_DRIVER).equals("oracle.jdbc.driver.OracleDriver")) {
			// select table_name from user_tables
			Statement statement = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			ResultSet r = statement.executeQuery("select table_name from user_tables");
			return r;
		} else {
			// postgres and mysql
			DatabaseMetaData metdata = conn.getMetaData();
			String catalog = null;
			String schemaPattern = "%";
			String tableNamePattern = "%";
			String types[] = { "TABLE" };
			conn.setAutoCommit(true);
			ResultSet r = metdata.getTables(catalog, schemaPattern, tableNamePattern, types);
			conn.setAutoCommit(false);
			return r;
		}
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private JButton cmdRefresh;
	private JPanel pnlButtons;
	private JScrollPane scrAttributesTable;
	private JScrollPane scrRelationsTable;
	private JSplitPane splRelationsColumns;
	private JTable tblAttributes;
	private JTable tblRelations;

	// End of variables declaration//GEN-END:variables

	private class CountTuplesAction implements OBDAProgressListener {

		CountDownLatch latch = null;
		Thread thread = null;
		String result = "-1";
		String table = null;
		Statement statement = null;

		private CountTuplesAction(CountDownLatch latch, String table) {
			this.latch = latch;
			this.table = table;
		}

		public String getResult() {
			return result;
		}

		public void run() {
			thread = new Thread() {
				@Override
				public void run() {
					try {
						Connection con = JDBCConnectionManager.getJDBCConnectionManager().getConnection(selectedSource.getSourceID());
						statement = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
						ResultSet r = statement.executeQuery("SELECT COUNT(*) FROM " + table.toUpperCase());
						r.next();
						if (r.first()) {
							Object temp = r.getObject(1);
							String count = temp.toString();
							result = count;
						}
						latch.countDown();
					} catch (Exception e) {
						latch.countDown();
						JOptionPane.showMessageDialog(null, "Error while counting tuples in " + table
								+ ".\n Please refer to the log file for more information.");
						log.error("Error while counting tuples in " + table, e);
					}
				}
			};
			thread.start();
		}

		@Override
		public void actionCanceled() throws Exception {
			if (thread != null) {
				thread.interrupt();
			}
			if (statement != null && !statement.isClosed()) {
				statement.cancel();
				statement.close();
			}
			latch.countDown();
		}
	}

	private class CountAllTuplesAction implements OBDAProgressListener {

		CountDownLatch latch = null;
		Thread thread = null;
		String[] result = null;
		Statement statement = null;

		private CountAllTuplesAction(CountDownLatch latch) {
			this.latch = latch;
		}

		public String[] getResult() {
			return result;
		}

		public void run() {
			thread = new Thread() {
				@Override
				public void run() {
					try {
						int rows = tblRelations.getRowCount();
						result = new String[rows];
						for (int i = 0; i < rows; i++) {
							String s = tblRelations.getModel().getValueAt(i, 0).toString();
							Connection con = JDBCConnectionManager.getJDBCConnectionManager().getConnection(selectedSource.getSourceID());
							statement = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
							ResultSet r = statement.executeQuery("SELECT COUNT(*) FROM " + s.toUpperCase());
							r.next();
							if (r.first()) {
								Object temp = r.getObject(1);
								String count = temp.toString();
								result[i] = count;
							} else {
								result[i] = "count error";
							}
							statement.close();
						}
						latch.countDown();
					} catch (Exception e) {
						latch.countDown();
						JOptionPane.showMessageDialog(null,
								"Error while counting tuples.\n Please refer to the log file for more information.");
						log.error("Error while counting tuples.", e);
					}
				}
			};
			thread.start();
		}

		@Override
		public void actionCanceled() throws Exception {
			if (thread != null) {
				thread.interrupt();
			}
			if (statement != null && !statement.isClosed()) {
				statement.cancel();
				statement.close();
			}
			latch.countDown();
		}
	}

	private class UpdateRelationTableAction implements OBDAProgressListener {

		CountDownLatch latch = null;
		Thread thread = null;
		ResultSet result = null;

		private UpdateRelationTableAction(CountDownLatch latch) {
			this.latch = latch;
		}

		@Override
		public void actionCanceled() throws Exception {
			if (thread != null) {
				thread.interrupt();
			}
			latch.countDown();
		}

		public ResultSet getResult() {
			return result;
		}

		public void run() {
			try {
				result = getResultSetForRelations();
				latch.countDown();
			} catch (Exception e) {
				latch.countDown();
				log.error("Error while retriving information from the data source.", e);
				JOptionPane.showMessageDialog(null, "Error while updating table.\n Please refer to the log file for more information.");
			}
		}
	}
}
