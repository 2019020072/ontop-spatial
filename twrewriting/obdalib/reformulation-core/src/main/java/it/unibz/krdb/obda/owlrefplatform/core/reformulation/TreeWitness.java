package it.unibz.krdb.obda.owlrefplatform.core.reformulation;

import java.util.HashSet;
import java.util.Set;

import it.unibz.krdb.obda.model.Atom;
import it.unibz.krdb.obda.model.Term;

/**
 * TreeWitness: tree witnesses as in the KR 2012 paper
 *     each tree witness is determined by its domain, root terms and the \exists R.B concept 
 *           that generates a tree in the TBox canonical model to embed the tree witness part of the query
 *           
 *           roots are the terms that are mapped to the root of that tree
 *           
 *           the "tree witness part of the query" consists of all atoms in the query 
 *                       with terms in the tw domain and at least one of the terms not being a tw root
 *                       
 *     each instance also stores those atoms of the query with all terms among the tw roots
 *      
 *     this information is enough to produce the tree witness formula tw_f 
 *     
 * @author Roman Kontchakov
 *
 */

public class TreeWitness {
	private Set<Term> domain; // terms that are covered by the tree witness
	private Set<Term> roots;   // terms that are mapped onto the root of the tree witness
	private Set<Atom> rootAtoms; // atoms of the query that contain only the roots of the tree witness
	                            // these atoms must hold true for this tree witness to be realised
	private TreeWitnessGenerator gen; // the \exists R.B concept that realises the tree witness 
	                                          // in the canonical model of the TBox
	private boolean allRootsQuantified; // all the roots are quantified variables

	public TreeWitness(TreeWitnessGenerator gen, Set<Term> roots, boolean allRootsQuantified, Set<Atom> rootAtoms, Set<Term> nonroots) {
		this.gen = gen;
		this.roots = roots;
		this.allRootsQuantified = allRootsQuantified;
		this.rootAtoms = rootAtoms;
		this.domain = new HashSet<Term>(roots);
		domain.addAll(nonroots);
	}

	/**
	 * Set<Term> getRoots()
	 * 
	 * @return set of roots of the tree witness
	 */
	public Set<Term> getRoots() {
		return roots;
	}
	
	/**
	 * boolean allRootsQuantified()
	 * 
	 * @return true if all root terms are quantified variables 
	 */
	public boolean allRootsQuantified() {
		return allRootsQuantified;
	}
	
	/**
	 * Set<Term> getDomain()
	 * 
	 * @return the domain (set of terms) of the tree witness
	 */
	
	public Set<Term> getDomain() {
		return domain;
	}
	
	/**
	 * TreeWitnessGenerator getGenerator()
	 * 
	 * @return the tree witness generator \exists R.B
	 */
	
	public TreeWitnessGenerator getGenerator() {
		return gen;
	}
	
	/**
	 * Set<Atom> getRootAtoms()
	 * 
	 * @return query atoms with all terms among the roots of tree witness
	 */
	
	public Set<Atom> getRootAtoms() {
		return rootAtoms;
	}
	
	@Override
	public String toString() {
		return "tree witness generated by " + gen + "\n    with domain " + domain + " and roots " + roots + " and root atoms " + rootAtoms;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof TreeWitness) {
			TreeWitness other = (TreeWitness)obj;
			return //(this.hashCode() == other.hashCode()) && 
					this.gen.equals(other.gen) &&
					this.roots.equals(other.roots) && 
					this.rootAtoms.equals(other.rootAtoms) && 
					this.domain.equals(other.domain);			
		}
		return false;
	}
	
	@Override
	public int hashCode() {
		return gen.hashCode() ^ roots.hashCode() ^ rootAtoms.hashCode() ^ domain.hashCode(); 
	}
}
